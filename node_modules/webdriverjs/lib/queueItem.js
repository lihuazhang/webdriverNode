var newQueue = function ( scope ){

    var rootItem = newQueueItem( 'root', undefined, scope, [] );

    rootItem.isRoot = true;
    rootItem.queueIsRunning = false;
    rootItem.currentQueueItem = this;
    this.rootItem = this;

    return rootItem;
};

/**
 * QueueItem工厂
 * @param commandName
 * @param method
 * @param scope
 * @param args
 * @return {*}
 */
var newQueueItem = function ( commandName, method, scope, args ){

    return new QueueItem( commandName, method, scope, args )
};
/**
 * 每个方法被调用后产生的queue对象
 * @param commandName 方法名称
 * @param method 方法本身
 * @param scope 方法执行的上下文
 * @param args 方法执行的参数
 * @constructor
 */
var QueueItem = function (commandName, method, scope, args) {
    this.children = [];
    this.commandName = commandName;
    this.method = method;
    this.arguments = [];
    this.scope = scope;
    this.currentChildIndex = 0;
    // 用来标示item及其children是否都执行完毕
    this.isDone = false;
    // 用来标示item自身的method是否已经执行完毕
    this.isSelfDone = false;

    var self = this;
    var hasCallback = false;
    var proxyCallback;
    var currentArg;

    // 对函数调用时的参数重新进行组装, 添加回调
    for (var i = 0; currentArg = args[i]; i++) {

        // 若最后一个参数为function，则被当做回调函数
        if (typeof currentArg == "function" && i == (args.length - 1)) {

            hasCallback = true;

            // 对回调函数进行封装
            proxyCallback = (function (method, methodName) {
                return function (result) {

                    method.call(scope, result);

                    self.next();
                };
            })(currentArg, commandName);
        }
        else {
            this.arguments.push( currentArg );
        }
    }

    if (!hasCallback) {

        proxyCallback = (function () {
            return function () {
                self.next();
            };
        })();

    }

    this.arguments.push( proxyCallback );
};


/**
 * 执行item, 如果有children（或者在item执行的过程中添加了children），则继续执行children
 */
QueueItem.prototype.run = function () {

    var self = this;

    // switch to the current queue item to make future addings to the correct queue item
    self.rootItem.currentQueueItem = this;

    if( !this.isSelfDone ){

        // run the command
        this.method.apply( this.scope, this.arguments );
        this.isSelfDone = true;
    }

    // 执行children
    this.next();
};

/**
 * 想当前item添加child
 * @param item
 */
QueueItem.prototype.add = function (item) {

    // make a reference to its parent so we can travel back
    item.parent = this;
    item.rootItem = this.rootItem;

    // add the new item to this childrens list
    this.children.push( item );

    var queueIsRunning = item.rootItem.queueIsRunning;

    // 若队列还未运行，则开始运行
    if (!queueIsRunning) {

        // make sure we switch the running flag so that we dont run .next again when a new item is added.
        item.rootItem.queueIsRunning = true;

        // begin the que
        this.next();
    }
};

/**
 * 运行下一个children，如果都执行完毕，则done
 */
QueueItem.prototype.next = function () {

    // if we have more children, run the next
    // otherwise tell the item we are done
    if (this.currentChildIndex < this.children.length) {
        this.children[this.currentChildIndex].run();
        this.currentChildIndex++;
    }
    else {
        this.done();
    }
};

/**
 * 检查当前节点是否已经执行完毕
 */
QueueItem.prototype.done = function () {

    // 递归检查是否所有子节点都已经执行完毕
    var checkDoneChildren = this.getNextChildToRun();

    // 若还存在子节点，则执行
    if( checkDoneChildren ){

        this.isDone = false;
        checkDoneChildren.run();
    }
    // 若本身尚未执行，则执行
    else if( !this.isSelfDone ){

        this.isDone = false;
        this.run();
    }
    else {

        this.isDone = true;

        // 若当前节点不是根节点，则继续执行兄弟节点
        if ( this.parent ) {

            // 执行兄弟节点
            this.parent.next();
        }
        else {

            // 到此说明所有节点均执行完毕
            this.rootItem.queueIsRunning = false;
        }
    }

};

/**
 * 递归查找当前节点的所有后代节点中尚未执行的节点
 * @return {*}
 */
QueueItem.prototype.getNextChildToRun = function () {

    var child = null;

    for (var i = 0, ii = this.children.length; i < ii; i++) {

        if (this.children[i] && !this.children[i].isDone) {
            return this.children[i];
        }
        else {
            child = this.children[i].getNextChildToRun();
        }

    }

    return child;
};

exports.newQueue = newQueue;
exports.newQueueItem = newQueueItem;