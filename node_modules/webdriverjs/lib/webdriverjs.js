var http = require("http");
var fs = require('fs');
var path = require('path');
var infoHasBeenShown = false;
var QI = require('./queueItem');
var newQueue = QI.newQueue;
var newQueueItem = QI.newQueueItem;

var Config = require('./config');
var colors = Config.colors;
var errorCodes = Config.errorCodes;


/**
 * webDriver 对象
 * @param options
 * @constructor
 */
var WebdriverJs = function (options)//host, port, username, pass)
{
    options = options || {};

    var self = this,
        startPath = '/wd/hub',
        queue = [],
        queueIsRunning = false;

    self.chain = true;
    self.sessionId = null;
    self.queuedPaused = false;
    self.logQeue = [];

    /* log level
     * silent : no logs
     * command : command only
     * verbose : command + data
     */
    self.logLevel = options.logLevel || 'verbose';

    // where to save the screenshots. default to current folder
    self.screenshotPath = "";

    var defaultOptions = {
        host:options.host || 'localhost',
        port:options.port || 4444,
        method:'POST'
    };

    //	defaultOptions = self.extend(defaultOptions, options);

    // 用于描述client希望server支持的session的功能
    self.desiredCapabilities = {
        browserName:"firefox",
        version:"",
        javascriptEnabled:true,
        platform:"ANY"
    };

    if (options.desiredCapabilities) {
        self.desiredCapabilities = self.extend(self.desiredCapabilities, options.desiredCapabilities);
    }

    // 保存所有实现的 WebDriver Wire Protocol
    self.protocol = {"direct":{}};
    // 组合 WebDriver Wire Protocol 实现的功能
    self.commands = {"direct":{}};
    // 所有的测试方法
    self.tests = {"direct":{}};
    // 所有的断言
    self.assert = {"direct":{}};
    self.direct = {};
    self.custom = {};


    // create the first item of the queue, ie the root
    var rootItem = new QueueItem("root", "none", this, []);

    // mark it as the current context
    self.currentQueueItem = rootItem;


    // expose protocol with correct context
    addDirectCommands(self.direct, protocolCommands);

    // create queue commands for the protocol
    addQueueCommands(self, protocolCommands, protocolCommands);


    /* ------------------------ create commands ------------------------ */
    // expose protocol with correct context
    // addDirectCommands(self.commands.direct, commandList);

    // create the commands
    addQueueCommands(self, commandList, commandList);


    /* ------------------------ create tests ------------------------ */
    // expose protocol with correct context
    // addDirectCommands(self.tests.direct, testList);

    // create the commands
    addQueueCommands(self.tests, testList, testList);

    addQueueCommands(self.assert, assertList, assertList);


    /*if (username && accessKey) {
     var authString = username+":"+accessKey;
     var buf = new Buffer(authString);
     this.options['headers'] = {
     'Authorization': 'Basic '+ buf.toString('base64')
     }
     this.desiredCapabilities.platform = "VISTA";
     }*/

    if (self.logLevel !== 'silent' && !infoHasBeenShown) {
        console.log("");
        console.log(colors.yellow + "=====================================================================================" + colors.reset);
        console.log("");
        console.log("Selenium 2.0/webdriver protocol bindings implementation with helper commands in nodejs by Camilo Tapia.");
        console.log("For a complete list of commands, visit " + colors.lime + "http://code.google.com/p/selenium/wiki/JsonWireProtocol" + colors.reset + ". ");
        console.log("Not all commands are implemented yet. visit " + colors.lime + "https://github.com/Camme/webdriverjs" + colors.reset + " for more info on webdriverjs. ");
        //Start with " + colors.lime + "-h option" + colors.reset + " to get a list of all commands.");
        console.log("");
        console.log(colors.yellow + "=====================================================================================" + colors.reset);
        console.log("");

        infoHasBeenShown = true;
    }


//	console.log(process.argv)

};

WebdriverJs.addCommand = function ( commandName, command ){

    var prop = WebdriverJs.prototype;

    if ( prop[commandName] ) {
        throw "The command '" + commandName + "' is already defined!";
    }

    prop[commandName] = (function (internalCommandName) {

        return function () {

            var self = this;
            var newQueueItem = newQueueItem( internalCommandName, command, self, arguments );
            self.rootItem.currentQueueItem.add( newQueueItem );

            // when adding commands, we return the instance of the client to be able to chain
            if (self.chain) {
                return self;
            }
        };

    })(commandName);
};

WebdriverJs.prototype = {

    /**
     * 将方法添加到 this.direct 中，并且使得方法执行时的上下文为this
     * @param commands
     */
    addDirectCommands:function ( commands ) {

        var direct = this.direct;
        var self = this;
        var method;

        for (var command in commands) {

            method = commands[ command ];
            direct[ command ] = (function (method) {
                return function () {
                    var args = Array.prototype.slice.call(arguments);
                    method.apply( self, args );
                };
            })(method);
        }
    },

//  send the protocol command to the webdriver server
    executeProtocolCommand:function (requestOptions, callback, data) {
        var request = this.createRequest(requestOptions, data, callback);
        var stringData = JSON.stringify(data);

        if (this.logLevel === 'verbose' && stringData != "{}") {
            this.log(colors.brown + "DATA\t\t " + colors.reset + stringData);
        }

        request.write(stringData);
        request.end();
    },

    // create a set of request options
    createOptions:function (requestOptions) {

        var newOptions = self.extend(defaultOptions, requestOptions);


        var path = startPath;

        if (self.sessionId) {
            newOptions.path = newOptions.path.replace(':sessionId', self.sessionId);
        }

        if (newOptions.path && newOptions.path !== "") {
            path += newOptions.path;
        }

        newOptions.path = path;

        return newOptions;
    },


    setScreenshotPath:function (pathToSaveTo) {
        self.screenshotPath = pathToSaveTo;
        return self;
    },

// a basic extend method
    extend:function (base, obj) {
        var newObj = {};
        for (var prop1 in base) {
            newObj[prop1] = base[prop1];
        }
        for (var prop2 in obj) {
            newObj[prop2] = obj[prop2];
        }
        return newObj;
    },


    testMode:function () {
        this.log(colors.yellow + "NOW IN TEST MODE!" + colors.reset + "\n");
        this.logLevel = 'silent';
        return this;
    },

    silent:function () {
        this.logLevel = 'silent';
        return this;
    },

    noChain:function () {
        this.chain = false;
    },

// strip the content from unwanted characters
    strip:function (str) {
        var x = [],
            i = 0,
            il = str.length;

        for (i; i < il; i++) {
            if (str.charCodeAt(i)) {
                x.push(str.charAt(i));
            }
        }

        return x.join('');
    },

// A log helper with fancy colors
    log:function (message, content) {
        if (this.logLevel !== 'verbose') {
            return false;
        }

        var currentDate = new Date();
        var dateString = currentDate.toString().match(/\d\d:\d\d:\d\d/)[0];

        if (!content) {
            console.log(colors.dkgray + "[" + dateString + "]: " + colors.reset, message);
        }
        else {
            console.log(colors.dkgray + "[" + dateString + "]: " + colors.reset, message, "\t", JSON.stringify(content));
        }

    },

// a helper function to create a callback that doesnt return anything
    proxyResponseNoReturn:function (callback) {
        return function (response) {
            if (callback) {
                callback();
            }
        };
    },


    createRequest:function (requestOptions, data, callback) {
        if (typeof data == "function") {
            callback = data;
            data = "";
        }

        var fullRequestOptions = this.createOptions(requestOptions);

        this.log(colors.violet + "COMMAND\t" + colors.reset + fullRequestOptions.method, fullRequestOptions.path);

        fullRequestOptions.headers = {
            'content-type':'application/json',
            'charset':'charset=UTF-8'
        }

        // we need to set the requests content-length. either from the data that is sent or 0 if nothing is sent
        if (data != "") {
            fullRequestOptions.headers['content-length'] = JSON.stringify(data).length;
        }
        else {
            fullRequestOptions.headers['content-length'] = 0;
        }

        var request = http.request(fullRequestOptions, callback);

        var self = this;
        request.on("error", function (err) {
            self.log(colors.red + "ERROR ON REQUEST" + colors.reset);
            console.log(colors.red, err, colors.reset);
        });

        return request;
    },


// a helper function to create a callback that parses and checks the result
    proxyResponse:function (callback, options) {
        var self = this;
        var baseOptions = { saveScreenshotOnError:true};
        return function (response) {
            response.setEncoding('utf8');

            var data = "";
            response.on('data', function (chunk) {
                data += chunk.toString();
            });

            response.on('end',
                function () {
                    if (options) {
                        if (options.setSessionId) {
                            try {
                                var locationList = response.headers.location.split("/");
                                var sessionId = locationList[locationList.length - 1];
                                self.sessionId = sessionId;
                                self.log("SET SESSION ID ", sessionId);
                            }
                            catch (err) {
                                self.log(colors.red + "COULDNT GET A SESSION ID" + colors.reset);
                            }

                        }
                    }

                    var result;

                    try {
                        result = JSON.parse(self.strip(data));
                    }
                    catch (err) {
                        if (data !== "") {
                            self.log("/n" + colors.red + err + colors.reset + "/n");
                            self.log(colors.dkgrey + data + colors.reset + "/n");
                        }
                        result = {value:-1};

                        if (callback) {
                            callback(result);
                        }

                        return;
                    }


                    if (result.status === 0) {

                        var value = result.value.length > 50 ? result.value.substring(0, 49) + "..." : result.value;
                        self.log(colors.teal + "RESULT\t" + colors.reset, value);
                    }
                    else if (result.status === 7) {
                        result = {value:-1, status:result.status, orgStatus:result.status, orgStatusMessage:errorCodes[result.status].message};
                        self.log(colors.teal + "RESULT\t" + colors.reset, errorCodes[result.status].id);
                    }
                    else {


                        // remove the content of the screenshot temporarily so that cthe consle output isnt flooded
                        var screenshotContent = result.value.screen;
                        delete result.value.screen;
                        if (errorCodes[result.status]) {
                            self.log(colors.red + "ERROR\t" + colors.reset + "" + errorCodes[result.status].id + "\t" + errorCodes[result.status].message);

                        }
                        else {
                            self.log(colors.red + "ERROR\t" + colors.reset + "\t", result + "\t" + errorCodes[result.status].message);
                        }

                        try {
                            var jsonData = JSON.parse(data);
                            self.log("\t\t" + jsonData.value.message);
                        }
                        catch (err) {
                            self.log("\t\t" + data);
                        }


                        // add the screenshot again
                        result.value.screen = screenshotContent;
                        if (process.argv.length > 1) {
                            var runner = process.argv[1].replace(/\.js/gi, "");

                            var prePath = "";

                            if (self.screenshotPath === "") {
                                prePath = runner;
                            }
                            else {
                                prePath = self.screenshotPath + runner.substring(runner.lastIndexOf("/") + 1);
                            }

                            // dont save the screenshot if its an unknown error
                            if (result.status != 13) {
                                var errorScreenshotFileName = prePath + "-ERROR.AT." + self.currentQueueItem.commandName + ".png";
                                self.log(colors.red + "SAVING SCREENSHOT WITH FILENAME:" + colors.reset);
                                self.log(colors.brown + errorScreenshotFileName + colors.reset);
                                self.saveScreenshotToFile(errorScreenshotFileName, result.value.screen);
                            }
                        }

                    }

                    if (!self.sessionId) {
                        self.log(colors.red + "NO SESSION, EXITING" + colors.reset)
                        process.exit(1);
                    }

                    if (callback) {
                        //	console.log("run callback for protocol")
                        callback(result);
                    }
                }
            );
        };
    },

// log test result
    showTest:function (theTest, receivedValue, expectedValue, message) {
        if (theTest) {
            console.log(colors.green + "✔" + colors.reset + "\t" + message);
        }
        else {
            console.log(colors.red + "✖" + colors.reset + "\t" + message + "\t" + colors.white + expectedValue + colors.reset + " !== " + colors.red + receivedValue + colors.reset);
        }
    },


    saveScreenshotToFile:function (fileName, data) {
//console.log(fileName)
//	var buff = new Buffer(data, "binary"); 
//	console.log(data)
        fs.writeFile(fileName, data, "base64", function (err) {
                if (err) {
                    this.log(err);
                }
            }
        );
    }
};


// the acutal commands. read them dynamicaly
var protocolFiles = fs.readdirSync(__dirname + "/protocol/");
var protocolCommands = {};

for (var i = 0, ii = protocolFiles.length; i < ii; i++) {
    if (path.extname(protocolFiles[i]) == ".js") {
        var commandName = path.basename(protocolFiles[i], '.js');
        protocolCommands[commandName] = require("./protocol/" + protocolFiles[i]).command;

        WebdriverJs.addCommand( commandName, protocolCommands[commandName] );
    }
}


/*
 // ------------------ tests helpers ----------------
 var testFiles = fs.readdirSync(__dirname + "/tests/");
 for(var i = 0, ii = testFiles.length; i < ii; i++)
 {
 var commandName = path.basename(testFiles[i], '.js');
 WebdriverJs.prototype[commandName] = require("./tests/" + testFiles[i]).command;
 }
 */
// save the command list to a variable available to all


var commandFiles = fs.readdirSync(__dirname + "/commands/");
var commandList = {};

for (var i = 0, ii = commandFiles.length; i < ii; i++) {
    if (path.extname(commandFiles[i]) == ".js") {
        var commandName = path.basename(commandFiles[i], '.js');
        commandList[commandName] = require("./commands/" + commandFiles[i]).command;
    }
}


var testFiles = fs.readdirSync(__dirname + "/tests/");
var testList = {};

for (var i = 0, ii = testFiles.length; i < ii; i++) {
    if (path.extname(testFiles[i]) == ".js") {
        var commandName = path.basename(testFiles[i], '.js');
        testList[commandName] = require("./tests/" + testFiles[i]).command;
    }
}


var assertFiles = fs.readdirSync(__dirname + "/asserts/");
var assertList = {};
for (var i = 0, ii = assertFiles.length; i < ii; i++) {
    if (path.extname(assertFiles[i]) == ".js") {
        var commandName = path.basename(assertFiles[i], '.js');
        assertList[commandName] = require("./asserts/" + assertFiles[i]).command;
    }
}


var singletonInstance = null;

// expose the man function
// if we need a singleton, we provide the option here
exports.remote = function (options)//host, port, username, pass)
{
    // make sure we have a default options if none are provided
    options = options || {};

    if (options.singleton) {
        if (!singletonInstance) {
            singletonInstance = new WebdriverJs(options);
        }
        return singletonInstance;
    }
    else {
        return new WebdriverJs(options);//host, port, username, pass);
    }
};

(function () {

    var webInstance = new exports.remote();

    webInstance.constructor.prototype.showTest = function () {
        console.log('tes2423534654654654');
    };
})();
